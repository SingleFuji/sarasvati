#summary A concise mathematical description of the Sarasvati model

== Concise Natural Language Description ==

  * A graph is made up of nodes and arcs.
  * A subset of nodes are join nodes
  * A subset of nodes are start nodes
  * Nodes have the following properties
    * A guard function, which given a node token, returns one of Accept, Discard or Skip.
    * An execute function.
  * Arcs have the following properties 
    * start node
    * end node
    * non-unique label
  * A graph is executed by means of a process. A process tracks the current state of execution using node tokens, which exist on nodes, and arc tokens, which exist on arcs.

Graph execution has the following operations
  * StartProcess
    * Parameters: process
    * A graph is execution begins by placing a node token on every start node, and performs the AcceptNodeToken operation on each of these node tokens.
  * AcceptNodeToken 
    * Parameters: node token
    * Performed on a newly generated node token.
    * Executes the guard associated with the node
    * If the guard returns Accept: Executes the node
    * If the guard returns Discard: Marks the node token as discarded
    * If the guard returns Skip: Skip includes an arc label. This performs CompleteNodeToken with the given arc label
  * CompleteNodeToken
    * Parameters: node token, label
    * Generates an arc token every outgoing node from the given node with that label
    * ProcessArcToken is performed on each arc token generated
  * ProcessArcToken
    * Parameters: arc token
    * If the end node of the arc is a join node
      * An arc token must exist on all other arcs coming into the same end node which share a label with the current arc. If this condition is met, one arc token on each of the arcs is marked complete and a node token is created on the arc's end node. NodeTokenAccept is called on the new node token.
    * If the end node of the arc is not a join node, the arc token is immediately marked complete, a new node token is generated on the end node of the arc and AcceptNodeToken is performed on the new node token.

== The Model ==
A Sarasvati executable graph is defined as directed graph, with a token mapping of node and arc tokens over that graph.

=== Graph Definition ===

A Sarasvati graph is defined as 

*G* = ( *N*, *N,,j,,*, *N,,s,,*, *A*, *F,,g,,*, *F,,e,,*, *L* )

  * *N* is the set of nodes in the graph
  * *N,,j,,* is the set of join nodes in the graph. *N,,j,,* ⊂ *N*.
  * *N,,s,,* is the set of start nodes in the graph. *N,,s,,* ⊂ *N*.
  * *A* is the set of arcs in the graph
  * *F,,g,,* is the set of guard functions used by the graph.
    * Every guard function returns a tuple ( *r*, *l* )
    * *r* ∈ { _Accept_, _Discard_, _Skip_ }
    * *l* ∈ *L* ∪ { {} }
    * if *r* ≠ _Skip_ then *l* = {}
  * *F,,e,,* is the set of node execution functions used by the graph.
    * Every node execution function accepts the current process state and returns either the same process state, or a new process state.
  * *L* is the set of labels used in the graph

Every node *n* ∈ *N* is a tuple ( *f,,g,,*, *f,,e,,* ) where

  * *f,,g,,* ∈ *F,,g,,*
  * *f,,e,,* ∈ *F,,e,,*

An arc *a* ∈ *A* is a tuple ( *a,,start,,*, *a,,end,,*, *l* ) where

  * *a,,start,,* ∈ *N*
  * *a,,end,,* ∈ *N*
  * *l* ∈ *L*

=== Process Definition ===

Formally, a Sarasvati graph execution *S* (also known as a process) is defined as

*S* = ( *G*, *T*, *R*, *P*, *Q*, *i* )

where 

  * *G* is the graph being executed
  * *T* is the set of active node tokens
  * *R* is the set of active arc tokens
  * *P* is the set of unprocessed node tokens
  * *Q* is the set of unprocessed arc tokens
  * *i* is the current state counter

A node token is defined as a tuple (*n*, *i*) where 

  * *n* ∈ *N*
  * *i* corresponds to the process state counter at the time the node token is created

A node token is defined as a tuple (*a*, *i*) where 

  * *a* ∈ *A*
  * *i* corresponds to the process state counter at the time the node token is created

=== Process State Changes ===
There are a set of operations which are performed to advance the state of a process.

  * _startProcess_
  * _processPendingNodeTokens_
  * _acceptNodeToken_
  * _completeNodeToken_
  * _completeArcToken_

====Initial State====

Every process has the same basic state, through the referenced graph may, of course, be different.

S,,0,, = (G, {}, {}, {}, {}, 0)

====startProcess====
The _startProcess_ operation will create node tokens for each start node.

_startProcess_( S,,0,,) = S,,1,, = (G, {}, {}, { (*n*, 1) | *n* ∈ *N,,s,,* }, {}, 1)

====processPending====
The _processPending_ operation will pull tokens out of their pending queues and process them, until the queues are empty.

for S,,i,, = ( G, T,,i,,, R,,i,,, P,,i,,, Q,,i,,, i )

_processPending_( S,,i,,) = 
  # Select t = (n = (f,,g,,, f,,n,,),_int_) ∈ P,,i,,
  # Get the result (r,l) of the guard function f,,g,,
  # if r = _Accept_
    # S,,i+1,, = ( G, T,,i,,, ∪ t, R,,i,,, P,,i,, - t, Q,,i,,, i+1)
    # return acceptNodeToken(S,,i+1,,, t)
  #




in addition

  * For a given node *n* belonging to *N* and arc identifier *ident*, every arc *a* with *a,,start,,* = *n* and *name* = *ident* belongs to *n,,out(ident),,*. 
    * This corresponds to the set of outgoing arcs from *n* with identifier *ident*.
  * For a given node *n* belonging to *N* and arc identifier *ident*, every arc *a* with *a,,end,,* = *n* and *name* = *ident* belongs to *n,,in(ident),,*. 
    * This corresponds to the set of incoming arcs to *n* with identifier *ident*.
  * A node token *t,,n,,* belonging to *T,,N,,* is defined as {*n*}, where *n* is a member of *N*.
  * An arc token *t,,a,,* belonging to *T,,A,,* is defined as {*a*} where *a* is a member of *A*.