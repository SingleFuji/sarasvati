#summary Core Sarasvati engine concepts.

[GraphBasedWorkflow <-- Prev: Why graph based workflow?] ... [XMLFileFormat Next: XML File Format  -->]


= Core Concepts =

== Introduction ==
Graph based workflow/bpm engines are common. There are some general concepts which apply to most of them, but they also vary greatly in how some features are implemented, such as concurrency, synchronization and external references (these terms are defined below). 

We begin with the some definitions, move on to features likely to be common across most engines, then explain Sarasvati specifics.

== Definitions ==

Graphs come with a set of common terms. To begin with, a graph is made up a set of things, hereafter refered to as *nodes* and a set of connections between _nodes_, know as *arcs*.

  * *Graph* - Set of nodes, with set of arcs connecting the nodes. While graphs have a wider applicability, graph here is synonymous with process definition. 
    * Also know as: Process Definition, Network, Workflow

  * *Node* - An element of a graph. A node corresponds roughly to an action as defined [Workflow previously]. Nodes can be thought of as pieces of code, waiting to be executed when their turn comes. 
    * Also known as: Vertex, Place

  * *Arc* - A directed connection between two nodes. 'Directed' means that arcs have a start node and an end node. In same cases, an arc may have a label, or name. Named arcs are discussed in more detail later. 
    * Also know as: Edge, Transition

  * *Predecessor* - If two nodes are connected by an arc then the node at the beginning of the arc is the _predecessor_ of the node at the end of the arc. How nodes are connected by arcs defines the order of execution. Generally a node may not execute until at last one, potentially many or all, of its predecessors has executed. Nodes may have many arcs exiting and entering them.

These definitions cover the parts of a process definition. However, they don't cover how that process definition is actually executed. When a process definition gets executed, it is called a *process*. Somehow, a process must track which nodes are being executed. This is generally accomplished by placing markers on the active nodes. These markers are generally called *tokens*.

  * *Process* - An executing process definition. A process definition may have have zero, one or many processes executing at any given time. 
    * Also known as: Case, Instance, Workflow

  * *Token* - The set of active tokens marks the current process state. Tokens generally point to a node which is currently executing. Tokens sometimes have associated state, which is a way of passing data from node to node. 
    * Also know as: Execution

== Sarasvati Graph Execution ==

Let us start with a simple process definition, the classic 'Hello World'. When executed, this process will print out 'Hello, World!' and then complete.

First, we introduce a graphical notation for process definitions and execution. Not all the symbols will make sense immediately, but they will all be explained.

[http://sarasvati.googlecode.com/svn/wiki/images/legend.jpg]

The simplest useful process definition would consist of a simple node. Here is the graphical representation:

*Example One*

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1.jpg]

How will this process be executed? First the engine needs to determine where to start execution. 

  * *Start Node* - A node at which a token will be placed when process execution begins.

There are various ways of handling this. For example, there may be a specific type of node designated for start positions. All nodes of this type will have tokens placed in them at process start. Alternately, nodes may have an attribute which indicates whether or not they are a start node, allowing any node to be a start node. Sarasvati takes this second approach.

Assuming that the 'Hello World' node is a start node, execution would begin by creating a new *node token* at the 'Hello World' node.

  * *Node Token* - A token situated at a node. As we will see later, there are also arc tokens (which are situated on arcs). They are distinct because they serve different functions.

The process would now look like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1-1.jpg]

As you can see, the node now has an active node token stationed on it.

At this point the node has not yet been executed. Before it can be though, its *guard* would need to be invoked.

  * *Node Guard* - Nodes have functionality associated with them, which will be executed when a node token is accepted into the node. However, before a node is executed, its guard will be executed. The guard will is allowed one of three responses:
    * *Accept* - The node will be executed.
    * *Discard* - The node token will be marked as discarded and the node will not be executed. 
    * *Skip*    - The node will _not_ be executed, however, processing will continue as if the node had completed execution normally.

By default, a node's guard will return Accept. The node will then be *executed*.

 This should cause 'Hello, World!' to be printed out. To complete node execution, the node must inform the engine that that the given node token has been completed. As there are no further steps in the process, it is now *complete* and looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1-2.jpg]

  * *Process Completion* - A process with no active tokens is considered complete.