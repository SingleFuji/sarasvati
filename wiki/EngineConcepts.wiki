#summary Core Sarasvati engine concepts.

[GraphBasedWorkflow <-- Prev: Why graph based workflow?] ... [XMLFileFormat Next: XML File Format  -->]


= Core Concepts =

== Introduction ==
Graph based workflow/bpm engines are common. There are some general concepts which apply to most of them, but they also vary greatly in how some features are implemented, such as concurrency, synchronization and external references (these terms are defined below). 

We begin with the some definitions, move on to features likely to be common across most engines, then explain Sarasvati specifics.

== Definitions ==

Graphs come with a set of common terms. To begin with, a graph is made up a set of things, hereafter refered to as *nodes* and a set of connections between _nodes_, know as *arcs*.

  * *Graph* - Set of nodes, with set of arcs connecting the nodes. While graphs have a wider applicability, graph here is synonymous with process definition. 
    * Also know as: Process Definition, Network, Workflow

  * *Node* - An element of a graph. A node corresponds roughly to an action as defined [Workflow previously]. Nodes can be thought of as pieces of code, waiting to be executed when their turn comes. 
    * Also known as: Vertex, Place

  * *Arc* - A directed connection between two nodes. 'Directed' means that arcs have a start node and an end node. In same cases, an arc may have a label, or name. Named arcs are discussed in more detail later. 
    * Also know as: Edge, Transition

  * *Predecessor* - If two nodes are connected by an arc then the node at the beginning of the arc is the _predecessor_ of the node at the end of the arc. How nodes are connected by arcs defines the order of execution. Generally a node may not execute until at last one, potentially many or all, of its predecessors has executed. Nodes may have many arcs exiting and entering them.

These definitions cover the parts of a process definition. However, they don't cover how that process definition is actually executed. When a process definition gets executed, it is called a *process*. Somehow, a process must track which nodes are being executed. This is generally accomplished by placing markers on the active nodes. These markers are generally called *tokens*.

  * *Process* - An executing process definition. A process definition may have have zero, one or many processes executing at any given time. 
    * Also known as: Case, Instance, Workflow

  * *Token* - The set of active tokens marks the current process state. Tokens generally point to a node which is currently executing. Tokens sometimes have associated state, which is a way of passing data from node to node. 
    * Also know as: Execution

== Sarasvati Graph Execution ==

Let us start with a simple process definition, the classic 'Hello World'. When executed, this process will print out 'Hello, World!' and then complete.

==== Legend ====
---------------------------------
First, we introduce a graphical notation for process definitions and execution. Not all the symbols will make sense immediately, but they will all be explained.

[http://sarasvati.googlecode.com/svn/wiki/images/legend.jpg]


==== Example One: Single Node ====
----------------------------------
The simplest useful process definition would consist of a simple node. Here is the graphical representation:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1.jpg]

How will this process be executed? First the engine needs to determine where to start execution. 

  * *Start Node* - A node at which a token will be placed when process execution begins.

There are various ways of handling this. For example, there may be a specific type of node designated for start positions. All nodes of this type will have tokens placed in them at process start. Alternately, nodes may have an attribute which indicates whether or not they are a start node, allowing any node to be a start node. Sarasvati takes this second approach.

Assuming that the 'Hello World' node is a start node, execution would begin by creating a new *node token* at the 'Hello World' node.

  * *Node Token* - A token situated at a node. Node tokens track the response of the node guard (see below). They may also have attributes. As we will see later, there are also arc tokens (which are situated on arcs). They are distinct because they serve different functions.

The process would now look like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1-1.jpg]

As you can see, the node now has an active node token stationed on it.

At this point the node has not yet been executed. Before it can be though, its *guard* would need to be invoked.

  * *Node Guard* - Nodes have functionality associated with them, which will be executed when a node token is accepted into the node. However, before a node is executed, its guard will be executed. The guard will is allowed one of three responses:
    * *Accept* - The node will be executed.
    * *Discard* - The node token will be marked as discarded and the node will not be executed. 
    * *Skip*    - The node will _not_ be executed, however, processing will continue as if the node had completed execution normally.

By default, a node's guard will return Accept. The node will then be *executed*. This should cause 'Hello, World!' to be printed out. 

  * *Node Execution* - When a node is executed, whatever custom logic has been assigned by the developer will run. To complete node execution, the node must inform the engine that that the given node token has been completed. Node completion may happen synchronously as part of the execution of the node function or it may happen later, asynchronously.

As there are no further steps in the process, it is now *complete* and looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1-2.jpg]

  * *Process Completion* - A process with no active tokens is considered complete.


====Example Two: Two nodes====
-------------------
Let's now example a slightly more complicated example. Instead of a single node, we'll have two, the first of which prints out 'Hello', the second prints out 'World'. It looks as follows:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2.jpg]

The _Hello_ node is a *predecessor* of the _World_ node. This dependency is indicated by the directed arc.

As the _Hello_ node is marked as a start node, a node token will be placed there when the process begins executing.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2-1.jpg]

When the node token on _Hello_ is completed, an *arc token* will be generated on the outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2-2.jpg]

  * *Arc Token* - A token situated on an arc. Arc tokens exist so that join nodes (see below) know when to execute. Arc tokens may not have attributes.

Since the arc on which the arc token is situated goes into a *non-join node*, a node token will be created on _World_ immediately.

  * *Non-join node* - A node which is activated whenever an arc token arrives on an incoming node. Activated means the incoming arc token is completed and an active node token is created. This stands in contrast to a *join node*, where active arc tokens must exist on all incoming arcs with the same name. This will be explored in more detail below.

The process now looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2-3.jpg]

The _World_ node will now run its guard and then execute. Finally the node token will be completed.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2-4.jpg]

====Example Three: Split and Join====
-------------------
Let us now examine an example which contains concurrent execution. 

The process describes an approval process. 
  # A request is made
  # Two approvals must be obtained
  # The request is granted

The process looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3.jpg]

This a simplified system, since it does not allow approvals to be denied.

There is more than one way that this process could be executed. 

  * If the approvals are granted by people, the nodes will almost certainly executed asynchronously. This means that when a token arrives at _Approval 1_, the node will generate a notification to the user who is to do the approval. The token will then enter a *wait state*. Execution may continue elsewhere in the process, but this token will wait until the user enters the system and grants approval. 
  * If approvals are done by software which does a check and then returns immediately the tokens will not have enter a *wait state*, but may continue immediately.

  * *Wait State* - When a token enters a node and the node is executed, it may choose not to immediately continue process execution at the end of the node method. In this case the token will remain in the node until it is complete asynchronously. While the token is waiting to be completed, it is considered to be in a wait state.

Let us view process execution for both these cases, starting with the case where approvals are done by people and thus tokens will need to enter wait states.

Execution will begin as usual, by placing a node token in the nodes marked as being start nodes.

The _Request_ node will be executed. It generates a task for the requester to complete. Until the requester has filled out out the request and completed the task, the token will be in a wait state. During this time the process will look like:


[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-1.jpg]

*Question:* What happens once the _Request_ has been completed? Which arc or arcs will arc tokens be generated on? 

*Answer:* Sarasvati requires that an arc name be specified when completing a node token. All arcs with this name will have arc tokens generated on them.

Some things to note:

  * Most arcs have no name specified. They are considered to have the 'default' name. 
  * Usually when completing a node token, the default arc name will be given.
  * Each arc will have an arc token placed on it in turn. No specific order is guaranteed
  * When an arc token is place on a node, it will continue on to node immediately and see if the node can be executed. 
 

So, now the node token on _Request_ has been completed and arc tokens will be generated on the outgoing arcs. First a node token will be generated on the upper arc (though order of arc execution is not guaranteed).

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-2.jpg]

This arc leads to a node which can be executed. The arc token will be completed and a node token will be placed in the _Approval 1_ node.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-3.jpg]

Here the node token will enter a wait state. Since no further execution can take place here, an arc token will now be generated on the second outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-4.jpg]

Again, since node _Approval 2_ can be executed immediately, the arc token will be completed and a node token will be created. It will also enter into a wait state once the notification to the user has been created.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-5.jpg]

At some point one of the approvals will be completed. Let's say that it's _Approval 2_. This will mark the node token complete and generate an arc token on the outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-6.jpg]

Now the engine will see if the  _Grant_ node can be executed. However, as the dashed border indicates, the _Grant_ node is a *join node*.

  * *Join node* - When an arc token arrives a join node, arc tokens must exist on all other arc *with the same name* before the node will accept a node token.

Since there are two arcs with the 'default' name coming into _Grant_, and only one of them has an arc token, the node can not be executed at this time. Execution will halt at this point.

At some point later, the token at _Approval 1_ is completed. This generates an arc token on the outgoing node.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-7.jpg]

Now when the engine tries to execute _Grant_ it finds arc tokens on all the incoming 'default' arcs. These arc tokens are marked complete and a node token is generated on _Grant_. 



[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-8.jpg]

Once the _Grant_ task is finished, its node token will also be completed and the process will be complete.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-9.jpg]