#summary Core Sarasvati engine concepts.

[GraphBasedWorkflow <-- Prev: Why graph based workflow?] ... [XMLFileFormat Next: XML File Format  -->]


= Core Concepts =

== Contents ==
 * [#Introduction Introduction]
 * [#Definitions Definitions]
 * [#Sarasvati_Graph_Execution Graph Execution Explained]
   * [#Legend  Legend]
   * [#Single_Node Single Node]
   * [#Two_Nodes Two Nodes]
   * [#Split_and_Join_with_Wait_States Split and Join - With Wait States]
   * [#Split_and_Join_without_Wait_States Split and Join - Without Wait States]
   * [#Flow_Control_with_Guards_using_Skip Flow Control with Guards using Skip]
   * [#Flow_Control_with_Guards_using_Discard Flow Control with Guards using Discard]
   * [#Flow_Control_with_Guards_using_Named_Arcs Flow Control with Guards using Named Arcs]
   * [#Flow_Control_from_Node_Completion_using_Named_Arcs Flow Control from Node Completion using Named Arcs]

==Introduction==
Graph based workflow/bpm engines are common. There are some general concepts which apply to most of them, but they also vary greatly in how some features are implemented, such as concurrency, synchronization and external references (these terms are defined below). 

We begin with the some definitions, move on to features likely to be common across most engines, then explain Sarasvati specifics.

==Definitions==

Graphs come with a set of common terms. To begin with, a graph is made up a set of things, hereafter refered to as *nodes* and a set of connections between _nodes_, know as *arcs*.

  * *Graph* - Set of nodes, with set of arcs connecting the nodes. While graphs have a wider applicability, graph here is synonymous with process definition. 
    * Also know as: Process Definition, Network, Workflow

  * *Node* - An element of a graph. A node corresponds roughly to an action as defined [Workflow previously]. Nodes can be thought of as pieces of code, waiting to be executed when their turn comes. 
    * Also known as: Vertex, Place

  * *Arc* - A directed connection between two nodes. 'Directed' means that arcs have a start node and an end node. In same cases, an arc may have a label, or name. Named arcs are discussed in more detail later. 
    * Also know as: Edge, Transition

  * *Predecessor* - If two nodes are connected by an arc then the node at the beginning of the arc is the _predecessor_ of the node at the end of the arc. How nodes are connected by arcs defines the order of execution. Generally a node may not execute until at last one, potentially many or all, of its predecessors has executed. Nodes may have many arcs exiting and entering them.

These definitions cover the parts of a process definition. However, they don't cover how that process definition is actually executed. When a process definition gets executed, it is called a *process*. Somehow, a process must track which nodes are being executed. This is generally accomplished by placing markers on the active nodes. These markers are generally called *tokens*.

  * *Process* - An executing process definition. A process definition may have have zero, one or many processes executing at any given time. 
    * Also known as: Case, Instance, Workflow

  * *Token* - The set of active tokens marks the current process state. Tokens generally point to a node which is currently executing. Tokens sometimes have associated state, which is a way of passing data from node to node. 
    * Also know as: Execution

[#Contents Back to Table of Contents]

== Sarasvati Graph Execution ==

Let us start with a simple process definition, the classic 'Hello World'. When executed, this process will print out 'Hello, World!' and then complete.

==== Legend ====
---------------------------------
First, we introduce a graphical notation for process definitions and execution. Not all the symbols will make sense immediately, but they will all be explained.

[http://sarasvati.googlecode.com/svn/wiki/images/legend.jpg]

[#Contents Back to Table of Contents]

==== Single Node ====
----------------------------------
The simplest useful process definition would consist of a simple node. Here is the graphical representation:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1.jpg]

How will this process be executed? First the engine needs to determine where to start execution. 

  * *Start Node* - A node at which a token will be placed when process execution begins.

There are various ways of handling this. For example, there may be a specific type of node designated for start positions. All nodes of this type will have tokens placed in them at process start. Alternately, nodes may have an attribute which indicates whether or not they are a start node, allowing any node to be a start node. Sarasvati takes this second approach.

Assuming that the 'Hello World' node is a start node, execution would begin by creating a new *node token* at the 'Hello World' node.

  * *Node Token* - A token situated at a node. Node tokens track the response of the node guard (see below). They may also have attributes. As we will see later, there are also arc tokens (which are situated on arcs). They are distinct because they serve different functions.

The process would now look like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1-1.jpg]

As you can see, the node now has an active node token stationed on it.

At this point the node has not yet been executed. Before it can be though, its *guard* would need to be invoked.

  * *Node Guard* - Nodes have functionality associated with them, which will be executed when a node token is accepted into the node. However, before a node is executed, its guard will be executed. The guard will is allowed one of three responses:
    * *Accept* - The node will be executed.
    * *Discard* - The node token will be marked as discarded and the node will not be executed. 
    * *Skip*    - The node will _not_ be executed, however, processing will continue as if the node had completed execution normally.

By default, a node's guard will return Accept. The node will then be *executed*. This should cause 'Hello, World!' to be printed out. 

  * *Node Execution* - When a node is executed, whatever custom logic has been assigned by the developer will run. To complete node execution, the node must inform the engine that that the given node token has been completed. Node completion may happen synchronously as part of the execution of the node function or it may happen later, asynchronously.

As there are no further steps in the process, it is now *complete* and looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts1-2.jpg]

  * *Process Completion* - A process with no active tokens is considered complete.

The entire process can be viewed [ConceptsExample1 here].

[#Contents Back to Table of Contents]

====Two Nodes====
-------------------
Let's now example a slightly more complicated example. Instead of a single node, we'll have two, the first of which prints out 'Hello', the second prints out 'World'. It looks as follows:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2.jpg]

The _Hello_ node is a *predecessor* of the _World_ node. This dependency is indicated by the directed arc.

As the _Hello_ node is marked as a start node, a node token will be placed there when the process begins executing.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2-1.jpg]

When the node token on _Hello_ is completed, an *arc token* will be generated on the outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2-2.jpg]

  * *Arc Token* - A token situated on an arc. Arc tokens exist so that join nodes (see below) know when to execute. Arc tokens may not have attributes.

Since the arc on which the arc token is situated goes into a *non-join node*, a node token will be created on _World_ immediately.

  * *Non-join node* - A node which is activated whenever an arc token arrives on an incoming node. Activated means the incoming arc token is completed and an active node token is created. This stands in contrast to a *join node*, where active arc tokens must exist on all incoming arcs with the same name. This will be explored in more detail below.

The process now looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts2-3.jpg]

The _World_ node will now run its guard and then execute. Finally the node token will be completed.


[http://sarasvati.googlecode.com/svn/wiki/images/concepts2-4.jpg]

The entire process can be viewed [ConceptsExample2 here].

[#Contents Back to Table of Contents]


====Split and Join with Wait States====
-------------------

Let us now examine an example which contains concurrent execution. 

The process describes an approval process. 
  # A request is made
  # Two approvals must be obtained
  # The request is granted

The process looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3.jpg]

This a simplified system, since it does not allow approvals to be denied.

There is more than one way that this process could be executed. 

  * If the approvals are granted by people, the nodes will almost certainly executed asynchronously. This means that when a token arrives at _Approval 1_, the node will generate a notification to the user who is to do the approval. The token will then enter a *wait state*. Execution may continue elsewhere in the process, but this token will wait until the user enters the system and grants approval. 
  * If approvals are done by software which does a check and then returns immediately the tokens will not have enter a *wait state*, but may continue immediately.

  * *Wait State* - When a token enters a node and the node is executed, it may choose not to immediately continue process execution at the end of the node method. In this case the token will remain in the node until it is complete asynchronously. While the token is waiting to be completed, it is considered to be in a wait state.

Let us view process execution for both these cases, starting with the case where approvals are done by people and thus tokens will need to enter wait states.

Execution will begin as usual, by placing a node token in the nodes marked as being start nodes.

The _Request_ node will be executed. It generates a task for the requester to complete. Until the requester has filled out out the request and completed the task, the token will be in a wait state. During this time the process will look like:


[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-1.jpg]

*Question:* What happens once the _Request_ has been completed? Which arc or arcs will arc tokens be generated on? 

*Answer:* Sarasvati requires that an arc name be specified when completing a node token. All arcs with this name will have arc tokens generated on them.

Some things to note:

  * Most arcs have no name specified. They are considered to have the 'default' name. 
  * Usually when completing a node token, the default arc name will be given.
  * Each arc will have an arc token placed on it in turn. No specific order is guaranteed
  * When an arc token is place on a node, it will continue on to its end node immediately and see if the node can be executed. 
 

So, now the node token on _Request_ has been completed and arc tokens will be generated on the outgoing arcs. First a node token will be generated on the upper arc (though order of arc execution is not guaranteed).

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-2.jpg]

This arc leads to a node which can be executed. The arc token will be completed and a node token will be placed in the _Approval 1_ node.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-3.jpg]

Here the node token will enter a wait state. Since no further execution can take place here, an arc token will now be generated on the second outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-4.jpg]

Again, since node _Approval 2_ can be executed immediately, the arc token will be completed and a node token will be created. It will also enter into a wait state once the notification to the user has been created.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-5.jpg]

At some point one of the approvals will be completed. Let's say that it's _Approval 2_. This will mark the node token complete and generate an arc token on the outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-6.jpg]

Now the engine will see if the  _Grant_ node can be executed. However, as the dashed border indicates, the _Grant_ node is a *join node*.

  * *Join node* - When an arc token arrives a join node, arc tokens must exist on all other arcs *with the same name* before the node will accept a node token.

Since there are two arcs with the 'default' name coming into _Grant_, and only one of them has an arc token, the node can not be executed at this time. Execution will halt at this point.

At some point later, the token at _Approval 1_ is completed. This generates an arc token on the outgoing node.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-7.jpg]

Now when the engine tries to execute _Grant_ it finds arc tokens on all the incoming 'default' arcs. These arc tokens are marked complete and a node token is generated on _Grant_. 


[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-8.jpg]

Once the _Grant_ task is finished, its node token will also be completed and the process will be complete.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-9.jpg]

The entire process can be viewed [ConceptsExampleSplitJoinOne here].

[#Contents Back to Table of Contents]

====Split and Join without Wait States====
-------------------
Lets now take a look at the same process, except now the approvals will be done by software and will not require a wait state.

The execution will be the same up to the point where _Approval 1_ is executing.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-3.jpg]

Previously, the node token went into a wait state. This time, the approval is done synchronously and the token will be completed. This will generate an arc token on the outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-10.jpg]

Again, the _Grant_ node is a join node, so it will wait for an arc token on the other incoming arc before executing. Execution will continue on the lower outgoing arc of _Request_.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-11.jpg]

Execution will continue into _Approval 2_.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-12.jpg]

This execution will also finish synchronously and an arc token will be generated on the outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-13.jpg]

Execution will finish as before now that all required incoming arcs have tokens on them.

The entire process can be viewed [ConceptsExampleSplitJoinTwo here].

[#Contents Back to Table of Contents]

====Flow Control with Guards using Skip====
-------------------
Now that we've seen how execution can split across arcs and join nodes can bring current executions back together, let us examine how to select which outgoing arcs receive tokens and which nodes get executed.

This example uses almost the same process as the previous example. The difference is that either or both approvals may be optional, depending on what is being requested. 

Let us pick up execution after the request has been entered and an arc token generated on the upper arc:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-2.jpg]

Now the node token will be generated in _Approval 1_. 

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-3.jpg]

However, remember that this does *not* mean that the node will immediately execute. First the *guard* must be invoked. Up until now, the guard has always been assumed to just return *Accept*. This time however, the guard is intelligent. It will check to see if this approval is required. If not, it will return a *Skip* response. 

  * *Skip* - A guard response which indicates that the node should not be executed, but that execution should continue on the outgoing nodes. An arc name may be specifying indicated which arcs should be used. If no arc name is given, arcs with the default name (unnamed arcs) will be used.

Assume that _Approval 1_ is not required. The node token will marked as having skipped the node, and execution will continue on the outgoing arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts3-16.jpg]

For the case where the guard for _Approval 2_ returns Accept, the entire execution can be seen [SkipExampleOne here].

[#Contents Back to Table of Contents]

====Flow Control with Guards using Discard====
-------------------
Having seen Skip, let us examine how to use the Discard response from guards. The same basic process definition is used, only this time, the assumption is that only one of the guards is required. 

The graph now looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts4.jpg]

Because we are using discard, only one token will reach _Grant_. This is why the _Grant_ node is no longer a *join node*.

Execution begins as normal. We pick up execution where a node token has been generated in _Approval 1_.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts4-3.jpg]

In this case, the guard determines that _Approval 1_ is not required, and returns a *Discard* response.

  * *Discard* - A guard response indicating that the node token should be marked as discard, the node should *not* be executed and no tokens will be generated on outgoing arcs.

The process now looks like:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts4-4.jpg]

The node token has been discarded, and execution has continued from the completion of _Request_ where an arc token has been generated on the lower outgoing arc. Execution will now continue as normal. 

[http://sarasvati.googlecode.com/svn/wiki/images/concepts4-5.jpg]

_Approval 2_ will accept its node token and will continue normally.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts4-6.jpg]

[http://sarasvati.googlecode.com/svn/wiki/images/concepts4-7.jpg]

Remember, because _Grant_ is no longer a join node, it will have a node token generated on it as soon as any arc tokens arrived.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts4-8.jpg]

The complete process can be seen [ConceptsExampleDiscardOne here].

[#Contents Back to Table of Contents]

====Flow Control with Guards using Named Arcs====
-------------------
This same basic process could be implemented using a guard which returns Skip along with an arc name.

In this variant, a _Select_ node has been inserted after _Request_. This node has no functionality, it only exists to give the guard a place to run.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts5.jpg]

It starts normally. Let us pick it up as _Select_ has a node token generated on it, and its guard is invoked.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts5-3.jpg]

The _Select_ guard will return a *Skip* response which includes the arc name on which to exit. *All arcs with this name will have an arc token generated on them*. In this case, let us say the guard determines that _Approval 2_ is required. It returns *Skip two*. An arc token is then generated on all arcs named _two_ (of which is there only one in this case).

[http://sarasvati.googlecode.com/svn/wiki/images/concepts5-4.jpg]

From here execution continues as normal.

The complete process can be seen [ConceptsExampleSkipTwo here].

[#Contents Back to Table of Contents]

====Flow Control from Node Completion using Named Arcs====
-------------------
As mentioned previously, when a node token is completed, an arc name must be specified. Arc tokens will be generated on all outgoing arcs with that name. So the previous example could also be implemented like this:

[http://sarasvati.googlecode.com/svn/wiki/images/concepts6.jpg]

Instead of using the guard on the _Select_ node, the _Request_ node will specify which arc to exit on.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts6-1.jpg]

If we again, specify _two_, the an arc token will be generated on that arc.

[http://sarasvati.googlecode.com/svn/wiki/images/concepts6-2.jpg]

From there, execution will continue normally.

The complete process can be seen [ConceptsExampleSelectArcOne here].

[#Contents Back to Table of Contents]